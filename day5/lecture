горутины - это отдельная сущность, управляется go-runtime
Прежде всего это про конкуретное выполнение

1) последовательное выполнение
2) параллельное выполнение. наличие соответсвущих устройств
   больше одного устройства, которые способны выполнять код.
3) конкурентное выполнение. нет необходимости в наличии нескольких ядер
   конкурентность означает, что наши задачи будут конкурировать за процессор
4) конкуретно-параллельное выполнение. Мы с этим и сталкиваемся

Два типа задач
1) cpu-bound задачи. задачи, привязанные к процессору. Это вычислительные задачи
   загружают процессор близко к 100%.
   при параллельном выполнии будут реальные преимущества
   при конкурентном выполнении преимущства не будет по производительности
2) io-bound задачи (ввод/вывод). характерезуются тем, что могут быть большие простои
   например, отправляем запрос и ждем долго ответ.
   за время ожидания мы можем выполнить множество других задач
   при конкуретном выполнии производительность сильно повысится

конкуретность:
1) вытесняющая многозадачность
   у нас есть внешний планировщик, который выделяет каждой задаче некий квант времени
   эти кванты времени одинаковые для всех задач
   одна задача выполняется, затем её принудительно планировщик останавливает и запускает следующую задачу
   большинство ОС поддерживают эту многозадачность
2) кооперативная многозадачность
   работает только в том случае, если все задачи "написаны одним автором"
   и нет реальной конкуренции за ресурсы
   случай, когда в прерывании задачи планировщик не участвует
   за прерывание задачи оотвечает сама задача
   она работает, потом отдает управление добровольно другим задачам

Процесс и поток
Два варианта запустить код конкуретно
можем сказать, что определенную часть кода можно запусть независимо
ЕСли есть ядра, то вполне возможно, что ОС апустит задачу параллельно
1) создать отдельный процесс
любая наша программа запустится в отдельном процессе
Главная особенность процессов - запуск в изолированном адресном пространстве
Если нужна коммуникация, мы обращаемся к ОС, она делает это за нас
недостатки с производительностью из-за коммуникации
Процесс требует выделение адресного пространства (ного ресурсов)

В свое время был предложен другой способ запуска программы параллельно - в потоках
Отличие потоков в том, что в одном процессе есть уже один поток
это просто набор инструкций
потоки могут быть запущены конкуретно или даже параллельно
потоки могут коммуницировать через общую память
потоки запускают быстрее, потоков можно запустить больше
Минус: надежность, если один поток сломается, все потоки сломаются
В зависимости, что нам нужно, мы можем выбирать: процессы или потоки

Если говорить о go, горутины работают исключительно поверх потоков, но это не поток
горутина - эта функция, которая может выполняться независимо
планировщик ставит на очередь на выполнение к каждому потоку
блокирование: мьютекс, ввод-вывод (обращение к жесткому диску), сетевое взаимодействие (сокеты)

две стратегии в случае блокирования:
1) планировщик берет этот поток (заблокированный) и вместо этого потока создает новый поток
   каждый раз, когда будет случаться, то будет брать поток из пулла
   то уменьшаем время на создание новых потоков, будем использовать старые потоки
2) ввод/вывод через сокеты.
   какой-то поток блокируется, когда это случилось, он заблокирован по факту слушания сокета
   здесь нет необходимости новый поток делать
   мы можем взять один поток (poller), получаем массив сокетов и слушаем все сразу
   все горутины, которые будут заблокированы, будут слушаться одним потоком

если мы имеем cpu-bound - запускаем задачу параллельно
io-bound - запускаем задачу конкуретно (poller/ пулл потоков)
планировщик go спроектирован так, чтобы наши задачи эффективно загружали процессоры

правила использования горутин:
максимально делать конкуретный код
горутины специально так спроектированы, что они весят максимально мало
не будут приводить к запуску новых потоков
всё, что можно запустить независимо, надо запускать независимо

